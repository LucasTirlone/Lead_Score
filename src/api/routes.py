# src/api/routes.py
import json
import logging
import os
import re
import secrets
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple

import fastapi
from fastapi import Body, Depends, File, HTTPException, Request, UploadFile, status
from fastapi.responses import JSONResponse, Response
from fastapi.security import HTTPBasic, HTTPBasicCredentials

from azure.ai.inference.aio import ChatCompletionsClient
from azure.core.exceptions import HttpResponseError

from .util import get_logger

# ===================== System Prompt =====================
LEAD_SCORER_PROMPT = r"""
You are “Noteefy‑AI‑Lead‑Scorer‑Pro”. Inputs are arbitrary JSON leads (schema varies by course/customer).
Discover signals and output a single valid JSON object with: run_id, active_lead_score_name, overview, and
scored_leads (each with submission_id, rating, score, estimated_revenue, reason, optional conflict_warnings).

Return ONLY a single valid JSON object using this contract:
{
  "run_id": "<ulid or UTC timestamp>",
  "active_lead_score_name": "<auto-generated concise title>",
  "overview": { "Very High": <int>, "High": <int>, "Medium": <int>, "Low": <int>, "Very Low": <int> },
  "scored_leads": [
    {
      "submission_id": "<original id if present; else stable hash>",
      "rating": "Very High|High|Medium|Low|Very Low",
      "score": <int 0-100>,
      "Number of days considered to estimated revenue": <int>,
      "estimated_revenue": <number OR the string 'no pricing seed available'>,
      "reason": "<≤400 chars, short narrative referencing the strongest signals, no PII>",
      "conflict_warnings": ["<≤400 chars>", ...]  // optional
    }
  ]
}

STRICT:
• Output must be valid JSON only (no prose).
• Labels exactly: Very High, High, Medium, Low, Very Low.
• No PII in reason/warnings (never echo emails, phones, postal codes).
• Process all leads; never abort on non‑fatal issues.
• Number of leads at the output must match the sum of all numbers of labels Very High, High, Medium, Low and Very Low from the "overview".

INPUT:
• User content includes {"leads":[...]} and MAY include {"pricing_seed": {...}}.
• Keys are dynamic; also inspect nested "submission_data".
• Dates can be ISO, YYYY‑MM‑DD, MM/DD/YYYY, or ranges "YYYY‑MM‑DD - YYYY‑MM‑DD".
• When there are multiple date ranges, "Number of days considered to estimated revenue" will be the number of days in the widest range.

DISCOVERY (per lead, best‑effort):
• submission_id: from _id.$oid | _id | submission_id | id | entity_id | else a stable hash.
• group_size: keys containing “group size|party size|players|guests|pax”; default 1.
• dates: arrays of ranges (e.g., SelectedDateRanges), paired Start/End or Arrival/Departure, or objects
  {start_date,end_date}. Normalize to list "YYYY‑MM‑DD - YYYY‑MM‑DD".
• lodging: any keys including lodging|room|suite|cottage|bed|occupancy → list of labels.
• contactability: phone_present if there is a phone/cell with ≥7 digits; text_opt_in/email_opt_in from truthy flags.
• notes: merge comment|instruction|note|notes and admin_notes[].note (deduped).

SCORING (deterministic; course‑agnostic). Start 50; clamp [0,100].
1) Party size: ≥8 +12; 4–7 +6; 2–3 +2; 1 +0.
2) Stay length & flexibility: widest range nights ≥4 +12; 2–3 +6; 1 +0. Multiple ranges/flex +6; 1‑night only −2.
3) Lodging intent: premium/fit for party +6…+10; concrete preference +3; none +0; mismatch −6.
4) Course richness & high‑spend cues: specific marquee/3+ courses/return‑guest/multi‑round +4…+8.
5) Contactability & engagement: phone_present +6; text_opt_in +3; email_opt_in +2; DNA/no phone −15; do‑not‑call −8.
6) Notes: strong buy‑signals +3…+10; weak/price‑check/day‑trip −3…−10.
7) Contradictions/missing essentials: invalid/missing dates −8; missing contact & no opt‑ins −8; garbage −5.

RATING:
  85–100 Very High; 70–84 High; 55–69 Medium; 40–54 Low; 0–39 Very Low.

ESTIMATED REVENUE:
• Only compute if "pricing_seed" is present in the user content; otherwise use the STRING:
  "no pricing seed available".
• Infer nights from the clearest or widest date window (if none, assume 1). Infer group_size (default 1).
• Determine price:
  - If exactly ONE lodging type is cited (matching a pricing_seed key or close variant), use THAT price.
  - If TWO OR MORE are cited, use the AVERAGE of the matched types’ prices.
  - If NONE match (or no lodging provided), use the AVERAGE of ALL prices in pricing_seed.
• estimated_revenue = nights × group_size × chosen_price.
• Output a number (e.g., 3600.0) or the exact string above.

REASON (≤400 chars): 1–3 sentences citing strongest signals grounded in the JSON (no PII).
WARNINGS (optional): only if justified (invalid dates, contradictions, lodging mismatch, fake phone, etc.).
SORT: sort scored_leads by rating (Very High→Very Low) then score desc; fill overview.
"""

# ===================== Auth opcional =====================
security = HTTPBasic()
username = os.getenv("WEB_APP_USERNAME")
password = os.getenv("WEB_APP_PASSWORD")
basic_auth_on = bool(username and password)

def authenticate(creds: Optional[HTTPBasicCredentials] = Depends(security)) -> None:
    if not basic_auth_on:
        return
    if not (secrets.compare_digest(creds.username, username) and
            secrets.compare_digest(creds.password, password)):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid credentials",
            headers={"WWW-Authenticate": "Basic"},
        )

auth_dep = Depends(authenticate) if basic_auth_on else None

# ===================== Infra & helpers =====================
logger = get_logger("azureaiapp_routes", logging.INFO, os.getenv("APP_LOG_FILE"), True)
router = fastapi.APIRouter()

def get_chat_client(request: Request) -> ChatCompletionsClient:  # type: ignore[return-type]
    return request.app.state.chat
def get_chat_model(request: Request) -> str:  # type: ignore[return-type]
    return request.app.state.chat_model

def _strip_code_fences(s: str) -> str:
    return s.replace("```json", "").replace("```", "").strip()

def _force_no_seed(parsed: Dict[str, Any]) -> Dict[str, Any]:
    """Garante a string no pricing quando o seed não está disponível no backend."""
    try:
        for it in parsed.get("scored_leads", []) or []:
            if isinstance(it, dict):
                it["estimated_revenue"] = "no pricing seed available"
    except Exception:
        pass
    return parsed

# ---- pricing seed: procura env, src/api/, src/api/data/ ----
def _load_pricing_seed() -> Optional[Dict[str, float]]:
    cand: List[Path] = []
    if os.getenv("PRICING_SEED_PATH"):
        cand.append(Path(os.getenv("PRICING_SEED_PATH", "")))
    here = Path(__file__).resolve().parent
    cand.append(here / "pricing_seed.json")          # src/api/pricing_seed.json
    cand.append(here / "data" / "pricing_seed.json") # src/api/data/pricing_seed.json
    for p in cand:
        try:
            if p.exists():
                data = json.loads(p.read_text(encoding="utf-8"))
                out: Dict[str, float] = {}
                for k, v in (data or {}).items():
                    try:
                        out[str(k)] = float(v)
                    except Exception:
                        continue
                if out:
                    logger.info("pricing_seed loaded from %s", p)
                    return out
        except Exception:
            continue
    logger.info("pricing_seed not found (ok: revenue will be disabled).")
    return None

# ---- parser robusto para arquivo “solto” ----
def _split_loose_json_objects(text: str) -> List[Dict[str, Any]]:
    """
    Varre o texto e extrai objetos JSON {…} balanceados, mesmo com vírgulas finais.
    Respeita strings/escapes; remove vírgulas antes de } ou ].
    """
    res: List[Dict[str, Any]] = []
    i = 0
    n = len(text)
    while i < n:
        # pular espaços, vírgulas e lixo
        while i < n and text[i] in " \t\r\n,;":
            i += 1
        if i >= n:
            break
        if text[i] != "{":
            nxt = text.find("{", i)
            if nxt == -1:
                break
            i = nxt
        start = i
        depth = 0
        in_str = False
        esc = False
        while i < n:
            ch = text[i]
            if in_str:
                if esc:
                    esc = False
                elif ch == "\\":
                    esc = True
                elif ch == '"':
                    in_str = False
            else:
                if ch == '"':
                    in_str = True
                elif ch == "{":
                    depth += 1
                elif ch == "}":
                    depth -= 1
                    if depth == 0:
                        raw = text[start : i + 1]
                        # remove vírgulas antes de } ou ]
                        cleaned = re.sub(r",\s*([}\]])", r"\1", raw)
                        try:
                            obj = json.loads(cleaned)
                            if isinstance(obj, dict):
                                res.append(obj)
                        except Exception:
                            pass
                        i += 1
                        break
            i += 1
    return res

def _unify_payload(payload: Any) -> Dict[str, Any]:
    """Aceita objeto único, lista, {'leads':[...]} e devolve {'leads':[...]}."""
    if isinstance(payload, dict) and "leads" in payload and isinstance(payload["leads"], list):
        leads = payload["leads"]
    elif isinstance(payload, list):
        leads = payload
    elif isinstance(payload, dict):
        leads = [payload]
    else:
        raise HTTPException(400, "Body must be an object, an array of objects, or {'leads':[...]}.")

    return {"leads": leads}

# ===================== Endpoints =====================
@router.get("/", summary="Index Name")
async def index_name(_ = auth_dep):
    return {"ok": True, "service": "lead-scorer-pro"}

@router.get("/health", summary="Healthcheck")
async def healthcheck():
    return {"ok": True}

@router.post("/lead-score", summary="Lead Score — JSON body")
async def lead_score(
    payload: Any = Body(..., description="Objeto, array de objetos ou {'leads':[...]}"),
    chat_client: ChatCompletionsClient = Depends(get_chat_client),
    model: str = Depends(get_chat_model),
    _ = auth_dep,
):
    if chat_client is None:
        raise HTTPException(500, "Chat client not initialized")

    unified = _unify_payload(payload)
    pricing = _load_pricing_seed()
    user_content: Dict[str, Any] = {"leads": unified["leads"]}
    if pricing:
        user_content["pricing_seed"] = pricing

    messages = [
        {"role": "system", "content": LEAD_SCORER_PROMPT},
        {"role": "user", "content": json.dumps(user_content, ensure_ascii=False)},
    ]
    try:
        resp = await chat_client.complete(model=model, messages=messages, temperature=0.1, max_tokens=7000)
        content = _strip_code_fences(resp.choices[0].message.content or "")
        parsed = json.loads(content or "{}")
        if not pricing:  # guarda
            parsed = _force_no_seed(parsed)
        return JSONResponse(content=parsed, status_code=200)
    except (HttpResponseError, json.JSONDecodeError) as e:
        logger.error("Model error: %s", e)
        raise HTTPException(500, "Model error or invalid JSON")

@router.post("/lead-score-file", summary="Lead Score — upload de arquivo")
async def lead_score_file(
    file: UploadFile = File(..., description="JSON, NDJSON ou 'solto' com vários objetos"),
    chat_client: ChatCompletionsClient = Depends(get_chat_client),
    model: str = Depends(get_chat_model),
    _ = auth_dep,
):
    if chat_client is None:
        raise HTTPException(500, "Chat client not initialized")

    text = (await file.read()).decode("utf-8", errors="ignore")

    def _parse_any(t: str) -> Dict[str, Any]:
        # 1) JSON normal (objeto, array, ou {"leads":[...]})
        try:
            data = json.loads(t)
            if isinstance(data, dict) and "leads" in data:
                leads = data["leads"]
            elif isinstance(data, list):
                leads = data
            else:
                leads = [data]
            return {"leads": leads}
        except Exception:
            pass
        # 2) NDJSON (um objeto por linha)
        leads: List[Dict[str, Any]] = []
        for line in t.splitlines():
            s = line.strip()
            if not s:
                continue
            try:
                obj = json.loads(s)
                if isinstance(obj, dict):
                    leads.append(obj)
            except Exception:
                continue
        if leads:
            return {"leads": leads}
        # 3) JSON “solto” (objetos colados, vírgula final, etc.)
        loose = _split_loose_json_objects(t)
        if loose:
            return {"leads": loose}
        raise HTTPException(400, "Arquivo vazio ou inválido.")

    unified = _parse_any(text)
    pricing = _load_pricing_seed()
    user_content: Dict[str, Any] = {"leads": unified["leads"]}
    if pricing:
        user_content["pricing_seed"] = pricing

    messages = [
        {"role": "system", "content": LEAD_SCORER_PROMPT},
        {"role": "user", "content": json.dumps(user_content, ensure_ascii=False)},
    ]
    try:
        resp = await chat_client.complete(model=model, messages=messages, temperature=0.1, max_tokens=7000)
        content = _strip_code_fences(resp.choices[0].message.content or "")
        parsed = json.loads(content or "{}")
        if not pricing:  # guarda
            parsed = _force_no_seed(parsed)
        return Response(
            content=json.dumps(parsed, ensure_ascii=False, indent=2),
            media_type="application/json",
            headers={"Content-Disposition": 'attachment; filename="scored_leads.json"'},
        )
    except (HttpResponseError, json.JSONDecodeError) as e:
        logger.error("Model error: %s", e)
        raise HTTPException(500, "Model error or invalid JSON")
